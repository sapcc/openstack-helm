apiVersion: v1
kind: ConfigMap
metadata:
  name: ironic-inspector-dhcp
  labels:
    system: openstack
    type: configuration
    component: ironic
data:
  config.json: |
    {"command":"staticDHCPd", "config_files":[{"source": "/var/lib/kolla/config_files/*", "dest": "/conf/", "owner": "root", "perm": "0300"}]}
  conf.py: |
    import dynamism, os, logging
    logger = logging.getLogger(__name__)

    DHCP_RESPONSE_INTERFACE = 'eth0'
    DHCP_SERVER_IP = os.getenv('POD_IP')
    DAEMON = False
    DEBUG = True
    WEB_ENABLED = False
    UID = 0
    GID = 0
    PXE_PORT = {{.Values.inspector.dhcp.proxy_port}}
    ALLOW_LOCAL_DHCP = False
    ALLOW_DHCP_RELAYS = True
    DATABASE_ENGINE = None
    USE_CACHE = False
    USE_POOL = False
    EMAIL_ENABLED = False

    def init():
      #Perform any required imports or setup operations within this function.
      pass

    def loadDHCPPacket(packet, method, mac, definition, relay_ip, port, source_packet):
      # packet.setOption(54, '{{.Values.inspector.dhcp.ip}}', force_selection=True)
      static_routes = []
      if method in ['DISCOVER', 'INFORM', 'REQUEST:RENEW', 'REQUEST:SELECTING', 'REQUEST:INIT-REBOOT']:
        logger.info("Pushing 169.254.0.0/16 link-local static routes")
        static_routes = [16,169,254,0,0,0,0] # we always want to push 169.254.0.0/16 as a link-local route
      default_gateway = packet.getOption('router')

      if default_gateway:
          logger.info("Pushing default route to gateway %s" % ".".join(str(n) for n in default_gateway))
          static_routes += [0] + default_gateway

      if static_routes:
        packet.setOption('classless_static_route', static_routes)

      # Set the relay agent option
      relay_agent = source_packet.getOption('relay_agent')
      if relay_agent:
        packet.setOption(82, relay_agent, force_selection=True)

      #PXE related junk
      if source_packet.getOption('vendor_class_identifier', convert=True):
          packet.setOption('vendor_class_identifier', 'PXEServer:staticDHCPd')
          packet.setOption('tftp_server_name', '{{.Values.tftp_ip}}')
          packet.setOption('bootfile_name', 'pxelinux.0')
          packet.setOption('siaddr', '{{.Values.tftp_ip}}')
          packet.setOption('file', 'pxelinux.0')

      return True

    def handleUnknownMAC(mac):
      return dynamism.provisionDynamic(mac)

    def filterRetrievedDefinitions(definitions, packet, method, mac, client_ip, relay_ip, port):
      print(definitions)
      return definitions[0]


  dynamism.py: |
    """
    Import this module from conf.py and call `provisionDynamic(mac)` to get dynamic
    allocations, good for use in a single-DHCP-server environment. Do be aware that
    no validation is performed to ensure that the DHCP request was legal, just that
    it was well-formed. Malicious clients cannot compromise the server, but they
    can trigger DoS behaviour. Given that there's nothing to gain, however, this is
    probably a non-issue.
    Please make changes to this module before using it in your environment. The
    default settings are almost certainly good for nobody.
    Consider setting 'renewal_time_value' and 'rebinding_time_value' to some number
    very close to, if not equal to, your lease-time, to avoid having clients extend
    leases longer than necessary; if you want a more persistent dynamic solution,
    you should be using the ISC server. The best use-case for this is giving
    unknown clients access to a guest subnet so they can be migrated to a static
    context.
    You can identify dynamic requests by using a unique subnet/serial pair and
    checking for it in loadDHCPPacket().
    """
    import collections
    import threading
    import time
    import ipaddress
    import logging
    logger = logging.getLogger(__name__)
    from staticdhcpdlib.databases.generic import Definition

    #Configure these variables as needed
    ###############################################################################
    LEASE_TIME = 600 #seconds
    SUBNET = 'ironic-inspector'
    SERIAL = 0

    #Add any elements you want to the list, as dotted-quad-notation IPv4 addresses
    _IPS = set([])

    _RANGE= u'{{.Values.inspector.dhcp.range}}'.split(',')
    _SUBNET = ipaddress.ip_network(u"{}/{}".format(_RANGE[0], _RANGE[-1]), False)
    _RANGE[0] = ipaddress.ip_address(_RANGE[0])
    _RANGE[1] = ipaddress.ip_address(_RANGE[1])
    _SUBNET_MASK = _RANGE[-1]

    _IPS = [str(ip) for ip in _SUBNET if ip >= _RANGE[0] and ip <= _RANGE[1]]

    _GATEWAY = '{{.Values.inspector.dhcp.options.router}}'
    _BROADCAST_ADDRESS = str(_SUBNET.broadcast_address)
    _DOMAIN_NAME = None
    ###############################################################################
    #Don't touch anything else, unless you want to (it's your network, after all)

    _IPS = collections.deque(sorted(_IPS)) #Redefine the set of IPs as an initially-sorted deque for sanity
    _IPS_LOCK = threading.Lock()
    _DYNAMIC_MAP = {}
    _DYNAMIC_MAP_LOCK = threading.Lock()

    #Finalise common strings
    _DOMAIN_NAME_SERVERS = "147.204.9.200,147.204.9.201"
    _NTP_SERVERS = ''
    _HOSTNAME_PATTERN = SUBNET + '-' + str(SERIAL) + '-'


    def _cleanupLeases():
      current_time = time.time()
      dead_records = []
      with _DYNAMIC_MAP_LOCK:
        for (mac, (expiration, ip)) in _DYNAMIC_MAP.items():
          if current_time - expiration > LEASE_TIME: #Kill it
            dead_records.append(mac)
            with _IPS_LOCK: #Put the IP back into the pool
              _IPS.append(ip)

        for mac in dead_records:
          del _DYNAMIC_MAP[mac]

    def _getLease(mac):
      ip = None
      with _DYNAMIC_MAP_LOCK:
        match = _DYNAMIC_MAP.get(mac)
        if match: #Renew the lease and take the IP
          match[0] = time.time() + LEASE_TIME
          ip = match[1]

          logger.debug("Extended lease of '%(ip)s' to '%(mac)s' until '%(time).1f'" % {
           'ip': ip,
           'mac': mac,
           'time': match[0],
          })
        else:
          with _IPS_LOCK:
            if _IPS:
              ip = _IPS.popleft()

          if ip:
            expiration = time.time() + LEASE_TIME
            _DYNAMIC_MAP[mac] = [expiration, ip]
            logger.debug("Bound '%(ip)s' to '%(mac)s' until '%(time).1f'" % {
             'ip': ip,
             'mac': mac,
             'time': expiration,
            })
      return ip

    def provisionDynamic(mac):
      """
      If you need to reject a MAC, return None instead of the usual value.
      """
      logger.debug("Processing dynamic provisioning request from '%(mac)s'..." % {'mac': mac,})

      _cleanupLeases() #Remove stale assignments
      ip = _getLease(mac)
      if not ip: #No IP available; fail
        logger.error("No IP available for assignment to '%(mac)s'" % {'mac': mac,})
        return None

      return Definition(ip, LEASE_TIME, SUBNET, SERIAL,
              _HOSTNAME_PATTERN + ip.replace('.', '-'),
              _GATEWAY, _SUBNET_MASK, _BROADCAST_ADDRESS,
              _DOMAIN_NAME, _DOMAIN_NAME_SERVERS,
              _NTP_SERVERS,
              )


  dnsmasq.conf: |
    no-resolv
    no-poll # Do not poll /etc/resolv.conf
    no-hosts
    user=root
    log-facility=-
    log-async
    log-dhcp
    keep-in-foreground
    port=0  # Disable DNS
    dhcp-sequential-ip
    dhcp-range={{.Values.inspector.dhcp.range}}
    dhcp-option=3,{{.Values.inspector.dhcp.options.router}}
    dhcp-option=6,147.204.9.200,147.204.9.201
    dhcp-boot=pxelinux.0,ironic-boot,{{.Values.tftp_ip}}
